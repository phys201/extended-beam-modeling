#from .config import modelconfimport numpy as npimport h5pyimport pandas as pddef load_tod_file(filename, type='mat7.3'):    """    Loads an external data file which contains :        -- calibrated but unfiltered detector timestreams (relative gain            correction has been applied, i.e. detectors in the same           pair have their responses normalized)        -- telescope pointing timestreams (not individual detector pointings)    Parameters    ----------    filename : string        path to file to be loaded    type : string, optional        'mat7.3' (default) -- the file is a .mat file saved with -v7.3 flag        No other options set up yet    Returns    -------    tuple of (signal, telescope_pointing, scan_ind)        signal : ndarray of size N_detectors x N_samples            detector signal, no summing / differencing yet applied        telescope_pointing : pandas DataFrame            contains horizon az/el/dk and celestial RA/dec/dk timestreams        scans : pandas DataFrame            contains indices marking beginning/end of az scan, as well as            direction and MJD time of each scan            """        # Method for loading file completely changes based on type    if type == 'mat7.3':        # Need to use h5py for this file type, loadmat won't work        f = h5py.File(filename,'r')                # For now assume all mat7.3 files are from BICEP/Keck and        # therefore have the same very specific file structure        signal = np.asarray(f['d']['mce0']['data']['fb'])                # Create telescope pointing dataframe        # The HDF5 formatting makes this ugly        telescope_pointing = pd.DataFrame({                'tel_hor_az': np.asarray(f['d']['pointing']['hor']['az']).flatten(),                'tel_hor_el': np.asarray(f['d']['pointing']['hor']['el']).flatten(),                'tel_hor_dk': np.asarray(f['d']['pointing']['hor']['dk']).flatten(),                'tel_cel_ra': np.asarray(f['d']['pointing']['cel']['ra']).flatten(),                'tel_cel_dec': np.asarray(f['d']['pointing']['cel']['dec']).flatten(),                'tel_cel_dk': np.asarray(f['d']['pointing']['cel']['dk']).flatten()})                # scan_ind will contain useful info about the telescope az scans        # The -1 is converting from MATLAB to python indexing        scans = pd.DataFrame({                'start': np.asarray(f['fs']['sf'],dtype='int').flatten()-1,                'end': np.asarray(f['fs']['ef'],dtype='int').flatten()-1,                'dir': np.asarray(f['fs']['inc'],dtype='int').flatten(),                'time_mjd': np.asarray(f['fs']['t']).flatten()})                            return signal, telescope_pointing, scansdef get_pair_timestream(signal, telescope_pointing, scans,                         pair_ind, halfscan_ind):    """    Take output of load_tod_file and pick out one fullscan for one detector    pair and put it in single dataframe.    Parameters    ----------    signal : ndarray of size N_detectors x N_samples        detector signal, no summing / differencing yet applied    telescope_pointing : pandas DataFrame        contains horizon az/el/dk and celestial RA/dec/dk timestreams    scans : pandas DataFrame        contains indices marking beginning/end of az scan, as well as        direction and MJD time of each scan    pair_ind : length-2 array of non-negative integers (pol A, pol B)        python indices identifying one detector , e.g. [201, 202]    halfscan_ind : array of non-negative integers        python indices identifying which half az scans to keep.         e.g. [1] keeps just the first halfscan,        [2,4] keeps halfscans 2, 3, and 4    Returns    -------    tod : pandas dataframe        contains polarization timestream of that pair, and         telescope pointing timestreams    """        # Which scans to keep.  +1 to keep the range inclusive.    ind_keep = np.array([np.arange(scans['start'][halfscan_ind[i]], scans['end'][halfscan_ind[i]] + 1) \                for i in range(len(halfscan_ind))], dtype='int')                # Polarization signal    A_det = pair_ind[0]    B_det = pair_ind[1]    signal_dif = signal[A_det,ind_keep] - signal[B_det,ind_keep]    signal_sum = signal[A_det,ind_keep] + signal[B_det,ind_keep]        # Copy scans dataframe and trim to desired scans    tod = telescope_pointing.loc[np.array(ind_keep).flatten()].reset_index(drop=True)        # Populate the rest of the output dataframe    tod['signal_dif'] = signal_dif.flatten()    tod['signal_sum'] = signal_sum.flatten()        return tod